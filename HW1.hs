{-# LANGUAGE GHC2024 #-}
-- Implement the following functions.
-- When you're done, ghc -Wall -Werror HW1.hs should successfully compile.
--
-- Tells HLS to show warnings, and the file won't be compiled if there are any warnings, e.g.,
-- eval (-- >>>) won't work.
{-# OPTIONS_GHC -Wall -Werror #-}
-- Refines the above, allowing for unused imports.
{-# OPTIONS_GHC -Wno-unused-imports #-}

module HW1 where

-- These import statement ensures you aren't using any "advanced" functions and types, e.g., lists.
import Prelude (Bool (..), Eq (..), Foldable (sum), Int, Integer, Num (..), Ord (..), abs, div, error, even, flip, fst, id, mod, not, odd, otherwise, snd, take, undefined, ($), (&&), (.), (^), (||))

------------------------------------------------
-- DO NOT MODIFY ANYTHING ABOVE THIS LINE !!! --
------------------------------------------------

---------------------------------------------------
-- Section 1: Function Composition & Transformation
---------------------------------------------------

curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
dropFst :: (a, b, c) -> (b, c)
dropSnd :: (a, b, c) -> (a, c)
dropThd :: (a, b, c) -> (a, b)
mapPair :: (a -> b) -> (a, a) -> (b, b)
pairApply :: (a -> b) -> (a -> c) -> a -> (b, c)
const :: a -> b -> a
constSecond :: a -> b -> b
const2 :: a -> b -> c -> a
-- Generatlizations of (.)
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d -- Hint: We saw this in class!
(.:.) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
(.::) :: (e -> f) -> (a -> b -> c -> d -> e) -> a -> b -> c -> d -> f
(.::.) :: (f -> g) -> (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> g
-- How can we ever implement such a function!?
impossible :: a -> b
---------------------------------------------------
-- Section 2: Function Composition & Transformation
---------------------------------------------------
-- Count the number of digits of an integer
countDigits :: Integer -> Integer
-- Sums the  digits of an integer
sumDigits :: Integer -> Integer
-- Reverses the  digits of an integer
reverseDigits :: Integer -> Integer
-- Returns the length of the Collatz sequence starting from x. collatzLength 1 = 0. You can assume the input is positive.
collatzLength :: Integer -> Integer

------------------------
-- Section 3: Generators
------------------------

-- Type definition for a generator: a function producing a sequence of values
-- 1. The first function generates the next value.
-- 2. The second function checks if generation should continue.
-- 3. The third value is the initial value, or seed. It does not count as being generated by the generator.
type Generator a = (a -> a, a -> Bool, a)

-- Retrieves the nth value from a generator. The seed does not count as an element. You can assume n >= 0.
nthGen :: Integer -> Generator a -> a
hasNext :: Generator a -> Bool
-- Behavior is undefined if the generator has stopped.
nextGen :: Generator a -> Generator a
-- Will not terminate if the generator does not stop.
lengthGen :: Generator a -> Integer
-- Should terminate for infinite generators as well.
hasLengthOfAtLeast :: Integer -> Generator a -> Bool
constGen :: a -> Generator a
foreverGen :: (a -> a) -> a -> Generator a
emptyGen :: Generator a

-- Generates all integers except 0.
integers :: Generator Integer
-- Sums all the values produced by a generator until it stops.
sumGen :: Generator Integer -> Integer
-- Checks if a generator produces a value that satisfies a predicate.
anyGen :: (a -> Bool) -> Generator a -> Bool
-- Adds an additional predicate to a generator.
andAlso :: (a -> Bool) -> Generator a -> Generator a
-- Bonus (15 points): Generates all positive divisors of a number smaller than the number itself.
divisors :: Integer -> Generator Integer
-----------------------------------
-- Section 4: Number classification
-----------------------------------

isPrime :: Integer -> Bool
nextPrime :: Integer -> Integer
primes :: Generator Integer
isHappy :: Integer -> Bool
isArmstrong :: Integer -> Bool
isPalindromicPrime :: Integer -> Bool
